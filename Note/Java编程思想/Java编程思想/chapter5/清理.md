#清理：终结处理和垃圾回收
Java中有垃圾回收器负责回收误用对象占据的内存资源。但也有特殊情况：假定你的对象（并非使用new）获得了一块“特殊”的内存区域，由于垃圾回收器只知道释放那些经由new分配的内存，所以不知道该如何释放该对象这块“特殊”的内存。



Java中没有像C/C++的析构函数，用来销毁不用的对象的内存空间，只有以下三个方法用于通知垃圾回收器回收对象。

1. finalize( )只是通知JVM的垃圾收集器当前的对象不再使用可以被回收了，但是垃圾回收器根据内存使用状况来决定是否回收。
finalize()最有用的地方是在JNI调用本地方法时(C/C++方法)，调用本地方法的析构函数消耗对象释放函数。
2.  System.gc()是强制析构，显式通知垃圾回收器释放内存，但是垃圾回收器也不一定会立即执行，垃圾回收器根据当前内存使用状况和对象的生命周期自行决定是否回收。
3. RunTime.getRunTime().gc()和System.gc()类似。

注意：这三个函数都不能保证垃圾回收器立即执行，推荐不要频繁使用

垃圾回收器原理：

1.	引用计数(ReferenceCounting)垃圾回收算法：
一种简单但是速度较慢的垃圾回收算法，每个对象拥有一个引用计数器(Reference Counter)，当每次引用附加到这个对象时，对象的引用计数器加1。当每次引用超出作用范围或者被设置为null时，对象的引用计数器减1。垃圾回收 器遍历整个对象列表，当发现一个对象的引用计数器为0时，将该对象移出内存释放。
引用计数算法的缺点是，当对象环状相互引用时，对象的引用计数器总不为0，要想回收这些对象需要额外的处理。
引用计数算法只是用来解释垃圾回收器的工作原理，没有JVM使用它实现垃圾回收器。
引用计数的改进算法：
任何存活的对象必须被在静态存储区或者栈(Stack)中的引用所引用，因此当遍历全部静态存储区或栈中的引用时，即可以确定所有存活的对象。每当 遍历一个引用时，检查该引用所指向的对象，同时检查该对象上的所有引用，没有引用指向的对象和相互自引用的对象将被垃圾回收器回收。

2. 暂停复制(stop-and-copy)算法：
垃圾回收器的收集机制基于：任何一个存活的对象必须要被一个存储在栈或者静态存储区的引用所引用。
暂停复制的算法是：程序在运行过程中首先暂停执行，把每个存活的对象从一个堆复制到另一个堆中，已经不再被使用的对象被回收而不再复制。
暂停复制算法有两个问题：
a.必须要同时维护分离的两个堆，需要程序运行所需两倍的内存空间。JVM的解决办法是在内存块中分配堆空间，复制时简单地从一个内存块复制到另一个内存块。
b.第二个问题是复制过程的本身处理，当程序运行稳定以后，只会产生很少的垃圾对象需要回收，如果垃圾回收器还是频繁地复制存活对象是非常低性能的。JVM的解决方法是使用一种新的垃圾回收算法——标记清除(mark-and-sweep)。
一般来说标记清除算法在正常的使用场景中速度比较慢，但是当程序只产生很少的垃圾对象需要回收时，该算法就非常的高效。

3. 标记清除(mark-and-sweep)算法：
和暂停复制的逻辑类似，标记清除算法从栈和静态存储区开始追踪所有引用寻找存活的对象，当每次找到一个存活的对象时，对象被设置一个标记并且不被回收，当标记过程完成后，清除不用的死对象，释放内存空间。
标记清除算法不需要复制对象，所有的标记和清除工作在一个内存堆中完成。
注意：SUN的文档中说JVM的垃圾回收器是一个后台运行的低优先级进程，但是在早期版本的JVM中并不是这样实现的，当内存不够用时，垃圾回收器先暂停程序运行，然后进行垃圾回收。
4. 分代复制(generation-copy)算法：
一种对暂停复制算法的改进，JVM分配内存是按块分配的，当创建一个大对象时，需要占用一块内存空间，严格的暂停复制算法在释放老内存堆之前要求把每个存活的对象从源堆拷贝到新堆，这样做非常的消耗内存。
通过内存堆，垃圾回收器可以将对象拷贝到回收对象的内存堆中，每个内存块拥有一个世代计数(generation count)用于标记对象是否存活。每个内存块通过对象被引用获得世代计数，一般情况下只有当最老的内存块被回收时才会创建新的内存块，这主要用于处理大 量的短存活周期临时对象回收问题。一次完整的清理过程中，内存块中的大对象不会被复制，只是根据引用重新获得世代计数。
JVM监控垃圾回收器的效率，当发现所有的对象都是长时间存活时，JVM将垃圾回收器的收集算法调整为标记清除，当内存堆变得零散碎片时，JVM又重新将垃圾回收器的算法切换会暂停复制，这就是JVM的自适应分代暂停复制标记清除垃圾回收算法的思想。

java即时编译技术(JIT)：

Java的JIT是just-in-timecomplier技术，JIT技术是java代码部分地或全部转换成本地机器码程序，不再需要JVM解释，执行速度更快。
当一个”.class”的类文件被找到时，类文件的字节码被调入内存中，这时JIT编译器编译字节码代码。

JIT有两个不足：

1. JIT编译转换需要花费一些时间，这些时间贯穿于程序的整个生命周期。
2. JIT增加了可执行代码的size，相比于压缩的字节码，JIT代码扩展了代码的size，这有可能引起内存分页，进而降低程序执行速度。
对JIT不足的一种改进技术是延迟评估(lazy evaluation)：其基本原理是字节码并不立即进行JIT编译除非必要，在最近的JDK中采用了一种类似延迟JIT的HotSpot方法对每次执行的代码进行优化，代码执行次数越多，速度越快。

